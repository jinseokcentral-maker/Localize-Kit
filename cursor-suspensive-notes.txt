Suspensive usage guide (LLM-friendly, happy-path-first)
=======================================================
목적
- React Suspense를 이용해 로딩/에러/비동기 흐름을 선언적으로 다루는 라이브러리 모음.
- 주로 사용할 패키지: @suspensive/react, @suspensive/react-query (우리 프로젝트: TanStack Query v5, React 18).

설치(참고)
- 이미 openapi-ts, tanstack-query가 있으므로 Suspensive만 추가 시: `pnpm add @suspensive/react @suspensive/react-query`

기본 원칙
- “happy path” UI만 작성하고, 로딩/에러는 Suspense + ErrorBoundary로 위임.
- 데이터 패칭은 Suspensive가 제공하는 Suspense용 쿼리 훅/컴포넌트를 사용 (`SuspenseQuery`, `SuspenseQueries`, `SuspenseInfiniteQuery`, `useSuspenseQuery` 등).
- 쿼리 정의는 tanstack의 `queryOptions`/`mutationOptions`를 사용해 타입 안정성을 유지하고, Suspensive 컴포넌트에 그대로 전달.
- 외부 요청/캐시/리트라이/에러 메시지는 쿼리 옵션에서 선언적으로 설정하고, 컴포넌트는 데이터 소비만 한다.

구성 요소 / 훅 요약 (@suspensive/react-query)
- SuspenseQuery, SuspenseQueries, SuspenseInfiniteQuery: 렌더 시 Suspense를 자동 트리거. fallback은 바깥의 `<Suspense>`에서 처리.
- useSuspenseQuery, useSuspenseInfiniteQuery: Suspense-aware 훅. 쿼리 실행 시 로딩/에러를 throw하여 Suspense/ErrorBoundary에 위임.
- PrefetchQuery, PrefetchInfiniteQuery, usePrefetchQuery/InfiniteQuery: 화면 진입 전에 쿼리 사전 로딩.
- mutationOptions: Mutation 설정을 선언적으로 래핑 (기존 tanstack mutationFn 대체).

에러/로딩 패턴
- 항상 `<ErrorBoundary>`와 `<Suspense fallback={...}>`를 함께 배치.
- 컴포넌트 본문에서는 `data`만 신뢰하고 분기 로직 최소화 → happy path 유지.
- 에러 메시지/재시도 버튼은 ErrorBoundary에서 처리.

프로젝트와의 결합 (예시)
- 이미 `QueryClientProvider`가 root.tsx에 있음.
- 인증 토큰은 `useTokenStore` + `apiClient`(커스텀 ky)로 자동 주입/리프레시.
- 예제: 사용자 정보 가져오기
```tsx
import { Suspense } from "react";
import { SuspenseQuery } from "@suspensive/react-query";
import { userControllerGetMeOptions } from "~/api/@tanstack/react-query.gen";
import { apiClient } from "~/api/authClient";

const userQuery = userControllerGetMeOptions({ client: apiClient });

function UserBox() {
  return (
    <Suspense fallback={<Spinner />}>
      <SuspenseQuery {...userQuery}>
        {(data) => <UserCard user={data} />}
      </SuspenseQuery>
    </Suspense>
  );
}
```

여러 쿼리 동시 실행
```tsx
<Suspense fallback={<Spinner />}>
  <ErrorBoundary fallback={<ErrorView />}>
    <SuspenseQueries
      queries={[
        userControllerGetMeOptions({ client: apiClient }),
        projectControllerListProjectsOptions({ client: apiClient }),
      ]}
    >
      {([me, projects]) => (
        <Dashboard me={me} projects={projects} />
      )}
    </SuspenseQueries>
  </ErrorBoundary>
</Suspense>
```

무한 스크롤 예시 (개념)
```tsx
const infiniteQuery = projectControllerListProjectsOptions({
  client: apiClient,
  query: { page: 1, limit: 20 },
});

<Suspense fallback={<Spinner />}>
  <SuspenseInfiniteQuery {...infiniteQuery}>
    {({ pages, fetchNextPage, hasNextPage }) => (
      <ProjectList
        pages={pages}
        onLoadMore={() => fetchNextPage()}
        hasMore={hasNextPage}
      />
    )}
  </SuspenseInfiniteQuery>
</Suspense>
```

추천 코드 스타일
- Suspense/Boundary는 페이지 또는 섹션 단위로 래핑하고, 내부 컴포넌트는 데이터 존재 가정.
- Effect 패턴과 병행: fetch 로직은 Effect.tryPromise 등으로 감싸거나 쿼리 함수 내부에서 처리해 throw가 Suspense로 전파되도록.
- 불필요한 상태(useState)나 분기(if !data ...)를 최소화. fallback/에러 UI는 상위 래퍼가 담당.

도입 체크리스트
- QueryClientProvider 존재 확인 (root.tsx OK).
- Suspense + ErrorBoundary를 페이지 최상단에 배치.
- tanstack query 옵션에서 `throwOnError: true`를 설정했는지 확인 (openapi-ts 생성본 기본 설정 확인).
- API 클라이언트는 `apiClient`(auth refresh 포함)를 사용해 인증 헤더 자동 주입.

주의 사항
- Suspense 모드에서는 쿼리 훅이 로딩/에러를 throw하므로 Boundary가 없으면 크래시.
- SSR 시 Suspense 지원 여부를 고려 (현재 ssr:false). CSR 환경에서는 문제 없음.
- 로딩 스피너/스켈레톤은 fallback으로만 처리하고, 본문에서는 제거.

